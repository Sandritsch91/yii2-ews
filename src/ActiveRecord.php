<?php
/**
 * @package yii2-ews
 * @author Simon Karlen <simi.albi@gmail.com>
 */

namespace simialbi\yii2\ews;

use Yii;
use yii\base\InvalidConfigException;
use yii\db\BaseActiveRecord;
use yii\helpers\ArrayHelper;

/**
 * Class ActiveRecord
 *
 * @property string $id => \jamesiarmes\PhpEws\Type\ItemIdType:ItemId.Id
 * @property string $changeKey => \jamesiarmes\PhpEws\Type\ItemIdType:ItemId.ChangeKey
 */
class ActiveRecord extends BaseActiveRecord
{
    /**
     * @var array
     */
    private $_attributeFields = [];

    /**
     * Declares the name of the corresponding php ews model name.
     * @return string
     * @throws InvalidConfigException
     */
    public static function modelName(): string
    {
        throw new InvalidConfigException(__METHOD__ . ' must be overridden.');
    }

    /**
     * Declares the representative fields from this AR class with the corresponding ews class.
     *
     * @return array
     */
    public static function attributeMapping(): array
    {
        return self::parseAttributes()[1];
    }

    /**
     * {@inheritDoc}
     */
    public static function primaryKey()
    {
        return ['id', 'changeKey'];
    }

    /**
     * {@inheritDoc}
     * @throws \yii\base\InvalidConfigException
     */
    public static function find()
    {
        return Yii::createObject(ActiveQuery::class, [get_called_class()]);
    }

    /**
     * {@inheritDoc}
     * @return \simialbi\yii2\ews\Connection
     * @throws \yii\base\InvalidConfigException
     */
    public static function getDb()
    {
        return Yii::$app->get('ews');
    }

    public static function updateAll($attributes, $condition = null)
    {
        parent::updateAll($attributes, $condition);
    }

    public static function deleteAll($condition = null)
    {
        parent::deleteAll($condition); // TODO: Change the autogenerated stub
    }

    /**
     * Parse attributes from PHP doc and return
     * @return array
     */
    final private static function parseAttributes(): array
    {
        $regex = '#^@property(?:-(read|write))?(?:\s+([^\s]+))?\s+\$([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)(?:\s+=>\s+(\\\\[\\\\a-zA-Z0-9\x7f-\xff]+)?:?([a-zA-Z0-9\x7f-\xff._]+))?#';
//        $typeRegex = '#^(bool(ean)?|int(eger)?|float|double|string|array)$#';
        $reflection = new \ReflectionClass(get_called_class());
        $docLines = preg_split('~\R~u', $reflection->getDocComment());
        $attributeFields = [];
        $attributeMeta = [];
        foreach ($docLines as $docLine) {
            $matches = [];
            $docLine = ltrim($docLine, "\t* ");
            if (preg_match($regex, $docLine, $matches) && isset($matches[3])) {
                if ($matches[1] === 'read' || empty($matches[2])) {
                    continue;
                }
                $attributeFields[] = $matches[3];
                $attributeMeta[$matches[3]] = [
                    'dataType' => explode('|', $matches[2]),
                    'foreignModel' => ArrayHelper::getValue($matches, 4),
                    'foreignField' => ArrayHelper::getValue($matches, 5)
                ];
            }
        }

        return [$attributeFields, $attributeMeta];
    }

    /**
     * {@inheritDoc}
     */
    public function attributes()
    {
        if (empty($this->_attributeFields)) {
            list($this->_attributeFields,) = self::parseAttributes();
        }

        return $this->_attributeFields;
    }

    /**
     * Inserts a row into the associated database table using the attribute values of this record.
     *
     * This method performs the following steps in order:
     *
     * 1. call [[beforeValidate()]] when `$runValidation` is `true`. If [[beforeValidate()]]
     *    returns `false`, the rest of the steps will be skipped;
     * 2. call [[afterValidate()]] when `$runValidation` is `true`. If validation
     *    failed, the rest of the steps will be skipped;
     * 3. call [[beforeSave()]]. If [[beforeSave()]] returns `false`,
     *    the rest of the steps will be skipped;
     * 4. insert the record into database. If this fails, it will skip the rest of the steps;
     * 5. call [[afterSave()]];
     *
     * In the above step 1, 2, 3 and 5, events [[EVENT_BEFORE_VALIDATE]],
     * [[EVENT_AFTER_VALIDATE]], [[EVENT_BEFORE_INSERT]], and [[EVENT_AFTER_INSERT]]
     * will be raised by the corresponding methods.
     *
     * Only the [[dirtyAttributes|changed attribute values]] will be inserted into database.
     *
     * If the table's primary key is auto-incremental and is `null` during insertion,
     * it will be populated with the actual value after insertion.
     *
     * For example, to insert a customer record:
     *
     * ```php
     * $customer = new Customer;
     * $customer->name = $name;
     * $customer->email = $email;
     * $customer->insert();
     * ```
     *
     * @param bool $runValidation whether to perform validation (calling [[validate()]])
     * before saving the record. Defaults to `true`. If the validation fails, the record
     * will not be saved to the database and this method will return `false`.
     * @param array $attributes list of attributes that need to be saved. Defaults to `null`,
     * meaning all attributes that are loaded from DB will be saved.
     * @return bool whether the attributes are valid and the record is inserted successfully.
     * @throws \Exception|\Throwable in case insert failed.
     */
    public function insert($runValidation = true, $attributes = null)
    {
        if ($runValidation && !$this->validate($attributes)) {
            Yii::info('Model not inserted due to validation error.', __METHOD__);
            return false;
        }

        if (!$this->beforeSave(true)) {
            return false;
        }
        $values = $this->getDirtyAttributes($attributes);
        if (false === ($data = static::getDb()->createCommand()->insert(static::class, $values))) {
            return false;
        }
        foreach ($data as $name => $value) {
            $this->setAttribute($name, $value);
        }

        $changedAttributes = array_fill_keys(array_keys($values), null);
        $this->setOldAttributes($values);
        $this->afterSave(true, $changedAttributes);

        return true;
    }
}
